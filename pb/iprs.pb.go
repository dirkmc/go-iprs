// Code generated by protoc-gen-go. DO NOT EDIT.
// source: iprs.proto

/*
Package iprs_pb is a generated protocol buffer package.

protoc --go_out=. *.proto

It is generated from these files:
	iprs.proto

It has these top-level messages:
	IprsEntry
*/
package iprs_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IprsEntry_ValidityType int32

const (
	// Setting an EOL says "this record is valid until..."
	IprsEntry_EOL IprsEntry_ValidityType = 0
	// Setting a time range says "this record is valid between x and y"
	IprsEntry_TimeRange IprsEntry_ValidityType = 1
)

var IprsEntry_ValidityType_name = map[int32]string{
	0: "EOL",
	1: "TimeRange",
}
var IprsEntry_ValidityType_value = map[string]int32{
	"EOL":       0,
	"TimeRange": 1,
}

func (x IprsEntry_ValidityType) Enum() *IprsEntry_ValidityType {
	p := new(IprsEntry_ValidityType)
	*p = x
	return p
}
func (x IprsEntry_ValidityType) String() string {
	return proto.EnumName(IprsEntry_ValidityType_name, int32(x))
}
func (x *IprsEntry_ValidityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IprsEntry_ValidityType_value, data, "IprsEntry_ValidityType")
	if err != nil {
		return err
	}
	*x = IprsEntry_ValidityType(value)
	return nil
}
func (IprsEntry_ValidityType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type IprsEntry_VerificationType int32

const (
	// Key verification verifies a record is signed with a private key
	IprsEntry_Key IprsEntry_VerificationType = 0
	// Cert verification verifies a record is signed by a certificate issued by a CA
	IprsEntry_Cert IprsEntry_VerificationType = 1
)

var IprsEntry_VerificationType_name = map[int32]string{
	0: "Key",
	1: "Cert",
}
var IprsEntry_VerificationType_value = map[string]int32{
	"Key":  0,
	"Cert": 1,
}

func (x IprsEntry_VerificationType) Enum() *IprsEntry_VerificationType {
	p := new(IprsEntry_VerificationType)
	*p = x
	return p
}
func (x IprsEntry_VerificationType) String() string {
	return proto.EnumName(IprsEntry_VerificationType_name, int32(x))
}
func (x *IprsEntry_VerificationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IprsEntry_VerificationType_value, data, "IprsEntry_VerificationType")
	if err != nil {
		return err
	}
	*x = IprsEntry_VerificationType(value)
	return nil
}
func (IprsEntry_VerificationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 1}
}

type IprsEntry struct {
	Value            []byte                      `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	Signature        []byte                      `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"`
	VerificationType *IprsEntry_VerificationType `protobuf:"varint,3,req,name=verificationType,enum=iprs.pb.IprsEntry_VerificationType" json:"verificationType,omitempty"`
	Verification     []byte                      `protobuf:"bytes,4,req,name=verification" json:"verification,omitempty"`
	ValidityType     *IprsEntry_ValidityType     `protobuf:"varint,5,opt,name=validityType,enum=iprs.pb.IprsEntry_ValidityType" json:"validityType,omitempty"`
	Validity         []byte                      `protobuf:"bytes,6,opt,name=validity" json:"validity,omitempty"`
	Sequence         *uint64                     `protobuf:"varint,7,opt,name=sequence" json:"sequence,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *IprsEntry) Reset()                    { *m = IprsEntry{} }
func (m *IprsEntry) String() string            { return proto.CompactTextString(m) }
func (*IprsEntry) ProtoMessage()               {}
func (*IprsEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *IprsEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *IprsEntry) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *IprsEntry) GetVerificationType() IprsEntry_VerificationType {
	if m != nil && m.VerificationType != nil {
		return *m.VerificationType
	}
	return IprsEntry_Key
}

func (m *IprsEntry) GetVerification() []byte {
	if m != nil {
		return m.Verification
	}
	return nil
}

func (m *IprsEntry) GetValidityType() IprsEntry_ValidityType {
	if m != nil && m.ValidityType != nil {
		return *m.ValidityType
	}
	return IprsEntry_EOL
}

func (m *IprsEntry) GetValidity() []byte {
	if m != nil {
		return m.Validity
	}
	return nil
}

func (m *IprsEntry) GetSequence() uint64 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func init() {
	proto.RegisterType((*IprsEntry)(nil), "iprs.pb.IprsEntry")
	proto.RegisterEnum("iprs.pb.IprsEntry_ValidityType", IprsEntry_ValidityType_name, IprsEntry_ValidityType_value)
	proto.RegisterEnum("iprs.pb.IprsEntry_VerificationType", IprsEntry_VerificationType_name, IprsEntry_VerificationType_value)
}

func init() { proto.RegisterFile("iprs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 261 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x8f, 0xcf, 0x6a, 0x83, 0x40,
	0x10, 0xc6, 0xb3, 0x6a, 0x9a, 0x38, 0x58, 0x59, 0x86, 0x1e, 0x96, 0xd2, 0x83, 0x08, 0x0d, 0xd2,
	0x83, 0x87, 0xbc, 0x42, 0xc9, 0xa1, 0x7f, 0xa0, 0xb0, 0x84, 0xdc, 0xad, 0x99, 0x86, 0x85, 0x54,
	0xed, 0xb8, 0x0a, 0xbe, 0x44, 0x9f, 0xb9, 0xc4, 0x52, 0xab, 0x29, 0xf4, 0xf8, 0xfb, 0x66, 0xe6,
	0xfb, 0x31, 0x00, 0xa6, 0xe2, 0x3a, 0xad, 0xb8, 0xb4, 0x25, 0x86, 0x4c, 0x79, 0xc9, 0xfb, 0xda,
	0x96, 0x4c, 0x69, 0xf5, 0x1a, 0x7f, 0xba, 0xe0, 0x3f, 0x54, 0x5c, 0x6f, 0x0a, 0xcb, 0x1d, 0x5e,
	0xc1, 0xbc, 0xcd, 0x8e, 0x0d, 0x29, 0x11, 0x39, 0x49, 0xa0, 0xbf, 0x01, 0x6f, 0xc0, 0xaf, 0xcd,
	0xa1, 0xc8, 0x6c, 0xc3, 0xa4, 0x9c, 0x7e, 0xf2, 0x1b, 0xe0, 0x0e, 0x64, 0x4b, 0x6c, 0xde, 0x4c,
	0x9e, 0x59, 0x53, 0x16, 0xdb, 0xae, 0x22, 0xe5, 0x46, 0x4e, 0x12, 0xae, 0xef, 0xd2, 0xa9, 0x2c,
	0x1d, 0x44, 0xe9, 0xee, 0xec, 0x42, 0xff, 0xe9, 0xc0, 0x18, 0x82, 0x71, 0xa6, 0xbc, 0x5e, 0x3c,
	0xc9, 0xf0, 0x11, 0x82, 0x36, 0x3b, 0x9a, 0xbd, 0xb1, 0x5d, 0xef, 0x9d, 0x47, 0x22, 0x09, 0xd7,
	0xab, 0x7f, 0xbc, 0xa3, 0x6d, 0x3d, 0xb9, 0xc5, 0x6b, 0x58, 0xfe, 0xb0, 0xba, 0x88, 0x44, 0x12,
	0xe8, 0x81, 0x4f, 0xb3, 0x9a, 0x3e, 0x1a, 0x2a, 0x72, 0x52, 0x8b, 0x48, 0x24, 0x9e, 0x1e, 0x38,
	0x5e, 0x41, 0x30, 0x6e, 0xc5, 0x05, 0xb8, 0x9b, 0x97, 0x67, 0x39, 0xc3, 0x4b, 0xf0, 0xb7, 0xe6,
	0x9d, 0x74, 0x56, 0x1c, 0x48, 0x8a, 0xf8, 0x16, 0xe4, 0xf9, 0xd7, 0xa7, 0xdd, 0x27, 0xea, 0xe4,
	0x0c, 0x97, 0xe0, 0xdd, 0x13, 0x5b, 0x29, 0xbe, 0x02, 0x00, 0x00, 0xff, 0xff, 0xfd, 0xf7, 0xb1,
	0x8a, 0xad, 0x01, 0x00, 0x00,
}
