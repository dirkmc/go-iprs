// Code generated by protoc-gen-go. DO NOT EDIT.
// source: iprs.proto

/*
Package recordstore_pb is a generated protocol buffer package.

It is generated from these files:
	iprs.proto

It has these top-level messages:
	IprsEntry
*/
package recordstore_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IprsEntry_ValidityType int32

const (
	// setting an EOL says "this record is valid until..."
	IprsEntry_EOL IprsEntry_ValidityType = 0
	// setting a time range says "this record is valid between x and y"
	IprsEntry_TimeRange IprsEntry_ValidityType = 1
	// setting a Certificate says "this record is valid if signed by a certificate issued by this certificate"
	IprsEntry_Cert IprsEntry_ValidityType = 2
)

var IprsEntry_ValidityType_name = map[int32]string{
	0: "EOL",
	1: "TimeRange",
	2: "Cert",
}
var IprsEntry_ValidityType_value = map[string]int32{
	"EOL":       0,
	"TimeRange": 1,
	"Cert":      2,
}

func (x IprsEntry_ValidityType) Enum() *IprsEntry_ValidityType {
	p := new(IprsEntry_ValidityType)
	*p = x
	return p
}
func (x IprsEntry_ValidityType) String() string {
	return proto.EnumName(IprsEntry_ValidityType_name, int32(x))
}
func (x *IprsEntry_ValidityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IprsEntry_ValidityType_value, data, "IprsEntry_ValidityType")
	if err != nil {
		return err
	}
	*x = IprsEntry_ValidityType(value)
	return nil
}
func (IprsEntry_ValidityType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type IprsEntry struct {
	Value            []byte                  `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	Signature        []byte                  `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"`
	ValidityType     *IprsEntry_ValidityType `protobuf:"varint,3,opt,name=validityType,enum=recordstore.pb.IprsEntry_ValidityType" json:"validityType,omitempty"`
	Validity         []byte                  `protobuf:"bytes,4,opt,name=validity" json:"validity,omitempty"`
	Sequence         *uint64                 `protobuf:"varint,5,opt,name=sequence" json:"sequence,omitempty"`
	Ttl              *uint64                 `protobuf:"varint,6,opt,name=ttl" json:"ttl,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *IprsEntry) Reset()                    { *m = IprsEntry{} }
func (m *IprsEntry) String() string            { return proto.CompactTextString(m) }
func (*IprsEntry) ProtoMessage()               {}
func (*IprsEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *IprsEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *IprsEntry) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *IprsEntry) GetValidityType() IprsEntry_ValidityType {
	if m != nil && m.ValidityType != nil {
		return *m.ValidityType
	}
	return IprsEntry_EOL
}

func (m *IprsEntry) GetValidity() []byte {
	if m != nil {
		return m.Validity
	}
	return nil
}

func (m *IprsEntry) GetSequence() uint64 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *IprsEntry) GetTtl() uint64 {
	if m != nil && m.Ttl != nil {
		return *m.Ttl
	}
	return 0
}

func init() {
	proto.RegisterType((*IprsEntry)(nil), "recordstore.pb.IprsEntry")
	proto.RegisterEnum("recordstore.pb.IprsEntry_ValidityType", IprsEntry_ValidityType_name, IprsEntry_ValidityType_value)
}

func init() { proto.RegisterFile("iprs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 221 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x8d, 0xc1, 0x4a, 0xc3, 0x40,
	0x10, 0x86, 0xdd, 0x24, 0xd5, 0x66, 0x88, 0x25, 0x0c, 0x1e, 0x16, 0xf1, 0x10, 0x7a, 0x90, 0x9c,
	0x16, 0xf1, 0x15, 0xa4, 0x07, 0x45, 0x10, 0x96, 0xe2, 0x3d, 0xb6, 0x43, 0x59, 0x88, 0xbb, 0xeb,
	0xec, 0xa4, 0x90, 0x27, 0xf0, 0xb5, 0xa5, 0x15, 0x63, 0x7b, 0x9b, 0xef, 0xff, 0xe7, 0xe7, 0x03,
	0x70, 0x91, 0x93, 0x89, 0x1c, 0x24, 0xe0, 0x82, 0x69, 0x13, 0x78, 0x9b, 0x24, 0x30, 0x99, 0xf8,
	0xb1, 0xfc, 0xce, 0xa0, 0x7c, 0x8e, 0x9c, 0x56, 0x5e, 0x78, 0xc4, 0x1b, 0x98, 0xed, 0xbb, 0x7e,
	0x20, 0xad, 0x9a, 0xac, 0xad, 0xec, 0x2f, 0xe0, 0x1d, 0x94, 0xc9, 0xed, 0x7c, 0x27, 0x03, 0x93,
	0xce, 0x8e, 0xcd, 0x7f, 0x80, 0x2f, 0x50, 0xed, 0xbb, 0xde, 0x6d, 0x9d, 0x8c, 0xeb, 0x31, 0x92,
	0xce, 0x1b, 0xd5, 0x2e, 0x1e, 0xef, 0xcd, 0xb9, 0xc8, 0x4c, 0x12, 0xf3, 0x7e, 0xf2, 0x6d, 0xcf,
	0xb6, 0x78, 0x0b, 0xf3, 0x3f, 0xd6, 0x45, 0xa3, 0xda, 0xca, 0x4e, 0x7c, 0xe8, 0x12, 0x7d, 0x0d,
	0xe4, 0x37, 0xa4, 0x67, 0x8d, 0x6a, 0x0b, 0x3b, 0x31, 0xd6, 0x90, 0x8b, 0xf4, 0xfa, 0xf2, 0x18,
	0x1f, 0xce, 0xe5, 0x03, 0x54, 0xa7, 0x1e, 0xbc, 0x82, 0x7c, 0xf5, 0xf6, 0x5a, 0x5f, 0xe0, 0x35,
	0x94, 0x6b, 0xf7, 0x49, 0xb6, 0xf3, 0x3b, 0xaa, 0x15, 0xce, 0xa1, 0x78, 0x22, 0x96, 0x3a, 0xfb,
	0x09, 0x00, 0x00, 0xff, 0xff, 0x22, 0x3c, 0xb4, 0x46, 0x26, 0x01, 0x00, 0x00,
}
